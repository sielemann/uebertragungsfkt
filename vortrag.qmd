---
title: "√úbertragungsfunktionen"
author: "Michael Sielemann"
date: "2025-09-19"
output: revealjs
format:
  revealjs:
    incremental: false
    theme: default
    mainfont: "Source Sans Pro"    
    fontsize: "28px"
    width: 1280
    height: 720
    margin: 0.1
    auto-stretch: true
    scrollable: true
    slide-number: true
    show-notes: false
    css: |
      .smaller {
        font-size: 0.8em;
      }
      .tiny {
        font-size: 0.6em;
      }
---

## Wiederholung 1

 - Mathematische Beschreibungen von dynamischen Systemen im Zeitbereich
   - ?

::: notes
Fragen
 - Welche mathematischen Beschreibungen von dynamischen Systemen im Zeitbereich kennen Sie?
:::

## Wiederholung 1

 - Mathematische Beschreibungen von dynamischen Systemen im Zeitbereich
   - Zustandsraumdarstellung f√ºr lineare Systeme
   - Differentialgleichung linear
   - Differentialgleichung nichtlinear

## Wiederholung 1

 - Mathematische Beschreibungen von dynamischen Systemen im Zeitbereich
   - Zustandsraumdarstellung f√ºr lineare Systeme <!-- Lunze Gl. 4.43 mit SISO, d.h. skalarem u, also Vektoren b, c, Skalar d -->
     $$
     \dot{x}(t) = A x(t) + B u(t), \quad x(0) = x_0
     $$
     $$
     y(t) = C x(t) + D u(t)
     $$
   - Differentialgleichung linear
   - Differentialgleichung nichtlinear

::: notes
Fragen
 - Wer kennt diese Darstellung schon (um abzusch√§tzen, wieviel Zeit ich f√ºr Wiederholung verwende)?
 - Warum linear? Weil A, B, C, D nicht von x oder u abh√§ngen.
 - Welche Gr√∂√üen haben A sowie B, C sowie D? nxn, nx1, 1xn, Skalar (wenn SISO, d.h. u und y L√§nge 1 haben)
:::



## Wiederholung 1

 - Mathematische Beschreibungen von dynamischen Systemen im Zeitbereich
   - Zustandsraumdarstellung f√ºr lineare Systeme
   - Differentialgleichung linear <!-- Lunze Gl. 4.3 -->
     $$
     a_n \frac{d^ny(t)}{dt^n} + a_{n-1} \frac{d^{n-1}y(t)}{dt^{n-1}} + \ldots + a_1 \frac{dy(t)}{dt} + a_0 y(t) = 
     $$
     $$
     = b_q \frac{d^q u(t)}{dt^q} + b_{q-1} \frac{d^{q-1} u(t)}{dt^{q-1}} + \ldots + b_1 \frac{du(t)}{dt} + b_0 u(t)
     $$
   - Differentialgleichung nichtlinear

::: notes
Fragen
 - Wer kennt diese Darstellung schon (um abzusch√§tzen, wieviel Zeit ich f√ºr Wiederholung verwende)?
 - Warum linear? Weil ai und bi nicht von x oder u abh√§ngen.
:::


## Wiederholung 1

 - Mathematische Beschreibungen von dynamischen Systemen im Zeitbereich
   - Zustandsraumdarstellung f√ºr lineare Systeme
   - Differentialgleichung linear
   - Differentialgleichung nichtlinear <!-- KJA Gl. 4.1 -->
     $$
     \dot{x}(t) = f(x,u), \quad x(0) = x_0
     $$
     $$
     y = h(x,u)
     $$

## Wiederholung 2

 - Bedeutung der Variablen
   - $u$?
   - $x$?
   - $y$?

::: notes
Fragen
 - Bedeutungen u, x, y??
 - Welche besondere Eigenschaft zeichnet Zustand aus? Speicher/Ged√§chtnis, kein instantane √Ñnderung sondern verz√∂gertes Verhalten und bleibender Einfluss
:::

## Wiederholung 2

 - Bedeutung der Variablen
   - $u$: Eingang
   - $x$: Zustand (bestimmt zusammen mit Verlauf der Eing√§nge sp√§tere Zust√§nde und Ausg√§nge eindeutig) <!-- Lunze Def. 4.1 -->
   - $y$: Ausgang

## Wiederholung 3

 - Wie k√∂nnen Simulationsaufgaben f√ºr lineare und nichtlineare Systeme berechnet werden? Welche Aufgaben gibt es?
   - ?

::: notes
Fragen
 - Welche Simulationsaufgaben kennen Sie? L√∂sung f√ºr beliebige, zeitvariable Eing√§nge (im Zeitbereich), station√§re Initialisierung, Linearisierung
 - Welche analytischen Methoden kennen Sie? Woraus wird die L√∂sung zusammengesetzt (besteht sie)?
 - Welche numerischen Methoden kennen Sie?
:::


## Wiederholung 3

 - Wie k√∂nnen Simulationsaufgaben f√ºr lineare und nichtlineare Systeme berechnet werden? Welche Aufgaben gibt es?
   - L√∂sung f√ºr beliebige, zeitvariable Eing√§nge $u(t)$ ausgehend von $x_0$
      - Analytisch mit *Faltungsgleichung* (nur f√ºr lineare Systeme, auch *Bewegungsgleichung*)
        - $x(t) = e^{At} x_0 + \int_0^t e^{A(t-\tau)} B u(\tau) d\tau$ <!-- KJA Gl. 5.14 und Lunze Gl. 5.13-->
        - $y(t) = C e^{At} x_0 + \int_0^t C e^{A(t-\tau)} B u(\tau) d\tau + D u(t)$ <!-- KJA Gl. 5.15 und Lunze Gl. 5.17-->
      - Numerisch mit Verfahren f√ºr gew√∂hnliche Differenzialgleichungen
        - Euler, Heun, Runge-Kutta
        - Mehrschrittverfahren etc.
   - Station√§re Initialisierung: Analytische oder numerische L√∂sung des algebraischen Systems
   - Linearisierung: Analytische oder numerische Auswertung von partiellen Ableitungen
   

::: notes
Fragen
 - Wie heissen der erste und zweite Summand der analytischen L√∂sung? Freie und erzwungene L√∂sung
:::

## Beispiel 1 {.unnumbered}

<div style="text-align: center; padding: 50px;">
  <a href="simulation1.html" target="_blank" style="font-size: 0.8em; padding: 20px; background: #039be5; color: white; text-decoration: none; border-radius: 10px;">
    Feder-Masse-Schwinger 1 in neuem Tab √∂ffnen
  </a>
</div>

::: notes
√ñffne die Simulation in einem neuen Tab. Danach mit Alt+Tab zur√ºck zur Pr√§sentation!
 - Linearisiertes Beispielmodell, √úbergangsverhalten, station√§res Verhalten mit sinusf√∂rmigen Eingangssignalen
 - Beim √Ñndern von Eingangsfrequenz √§ndern sich Frequenz und Verst√§rkung von Ausg√§ngen (Verschieben der Parameter: Masse √§ndert v.a. Amplitude, Federkonstante Amplitude und Phase, D√§mpfung vor allem Phase. Verschiebung der Eingangsparameter: Amplitude √§ndert Amplitude, Frequenz kann beides √§ndern wenn man an rechten Rand sieht aber nichts besonders eindeutiges).
 - Fehlt/nur erw√§hnen: Fourieranalyse und Superposition (Kann mit einfachen Signalen und Superpositionsprinzip viele Eing√§nge darstellen und Ausg√§nge berechnen). 
:::


## Lernziele heute

 - Ausgang f√ºr exponentielle Eing√§nge
 - √úbertragungsfunktion
 - Umrechnung von Zustandsraum zu √úbertragungsfunktion und umgekehrt
 - Laplace-Transformation und umgekehrte Laplace-Transformation


## Motivation

<div style="text-align: center;">

```{mermaid}
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#e1f5fe',
    'primaryTextColor': '#000000',
    'primaryBorderColor': '#039be5',
    'lineColor': '#333333',
    'fontFamily': 'Source Sans Pro, Arial, sans-serif'
  },
  'flowchart': {
    'nodeSpacing': 30,
    'rankSpacing': 40,
    'padding': 5
  }
}}%%
flowchart TD
    A["üõ©Ô∏è<br>Reales System"] 

    B["Modell"]
    B1["$$\dot{x} = f(x,u), \quad y = h(x,u)$$"]

    C["Linearisierung<br>und Normierung"]
    C1["$$\dot{x} = Ax + Bu, \quad y = Cx + Du$$"]

    E["√úbertragungsfunktion"]
    E1["heute"]
    
    F["Reglerentwurf"]    


    A --> B
    A ~~~ B1
    B --> C
    B ~~~ C1
    C --schwer--> F
    C --einfach--> E
    C ~~~ E1
    E --einfach--> F
    
    classDef model fill:#e1f5fe,stroke:#039be5,stroke-width:2px
    classDef process fill:#e8f5e9,stroke:#43a047,stroke-width:2px
    classDef equation fill:#f5f5f5,stroke:#666,stroke-dasharray: 5 5
    
    class A process
    class B,C,E model
    class F process
    class B1,C1,E1 equation
```

</div>

::: notes
Fragen
 - Warum k√∂nnte es schwer sein direkt von der Zustandsraumdarstellung den Reglerentwurf durchzuf√ºhren? Bekannt ist Ihnen bereits die Faltungsgleichung, die schwierig auszuwerten ist. Dazu lernen Sie heute weitere Gr√ºnde, weswegen der alternative Weg durch den Frequenzbereich und √úbertragungsfunktionen einfacher ist.
:::

## Motivation

<div style="text-align: center;">

```{mermaid}
%%{init: {
  'theme': 'base',
  'themeVariables': {
    'primaryColor': '#e1f5fe',
    'primaryTextColor': '#000000',
    'primaryBorderColor': '#039be5',
    'lineColor': '#333333',
    'fontFamily': 'Source Sans Pro, Arial, sans-serif'
  },
  'flowchart': {
    'nodeSpacing': 30,
    'rankSpacing': 40,
    'padding': 5
  }
}}%%
flowchart TD
    A["üõ©Ô∏è<br>Reales System"] 

    B["Modell"]
    B1["$$\dot{x} = f(x,u), \quad y = h(x,u)$$"]

    C["Linearisierung<br>und Normierung"]
    C1["$$\dot{x} = Ax + Bu, \quad y = Cx + Du$$"]

    E["√úbertragungsfunktion"]
    E1["heute!"]
    
    F["Reglerentwurf"]    


    A --> B
    A ~~~ B1
    B --> C
    B ~~~ C1
    C --Faltungsgleichung--> F
    C --einfach--> E
    C ~~~ E1
    E --einfach--> F
    
    classDef model fill:#e1f5fe,stroke:#039be5,stroke-width:2px
    classDef process fill:#e8f5e9,stroke:#43a047,stroke-width:2px
    classDef equation fill:#f5f5f5,stroke:#666,stroke-dasharray: 5 5
    
    class A process
    class B,C,E model
    class F process
    class B1,C1,E1 equation
```

</div>


## L√∂sung der Faltungsgleichung

 - Faltungsgleichung beschreibt Ausgang vollst√§ndig
     - $y(t) = C e^{At} x_0 + \int_0^t C e^{A(t-\tau)} B u(\tau) d\tau + D u(t)$ <!-- KJA Gl. 5.15 und Lunze Gl. 5.17-->
 - Die homogene L√∂sung $e^{At} x_0$ beschreibt das Verhalten des Systems ohne Eingang und kann ohne Schwierigkeiten berechnet werden
 - Die erzwungene L√∂sung $\int_0^t e^{A(t-\tau)} B u(\tau) d\tau$ beschreibt das Verhalten des Systems mit Eingang und stellt uns mit Faltungsintegral vor Herausforderungen
 - Um ein besseres Verst√§ndnis zu erhalten analysieren wir die Ausg√§nge f√ºr einfache Grundformen als Eing√§nge auf eine Weise die
   - einfach zu berechnen ist: Die Ausg√§nge haben die gleiche Form wie die Eing√§nge
   - reichhaltige Ergebnisse verspricht: Die meisten Eing√§nge k√∂nnen als Linearkombination von Grundformen beschrieben werden
 - Der Ausgang kann dann Dank Superposition aus den Ausg√§ngen f√ºr die Grundformen berechnet werden

::: notes
Fragen
 - Welche Ideen haben Sie f√ºr Eing√§nge, die gleiche Form wie Ausg√§nge haben? Sprung vielleicht? Schwingungen!
:::


## Exponentielle Eing√§nge 1

 - Ansatz f√ºr Grundform: $u(t) = e^{s t}$ mit $s \in \mathbb{C}$, einer komplexen Zahl
 - Ist $s$ reell, dann ergibt $u(t)$ eine einfache Exponentialfunktion
 - Ist $s$ komplex, dann verwendet man immer ein Paar von komplexer Zahl $s$ und Konjugierter $s^*$, so dass die Summe der Grundformen reell ist
 - Ist $s = j \omega$ und $s^* = -j \omega$, dann ergibt die Summe der Grundformen eine Kosinusfunktion
     - $u(t) + u^*(t) = e^{j \omega t} + e^{-j \omega t} = 2 \cos(\omega t)$
- Ist $s = \sigma + j \omega$ und $s^* = \sigma - j \omega$, dann ergibt die Summe der Grundformen eine Kosinusfunktion mit exponentiell auf- oder abklingenden Amplitude
     - $u(t) + u^*(t) = e^{\sigma t} e^{j \omega t} + e^{-\sigma t} e^{-j \omega t} = 2 e^{\sigma t} \cos(\omega t)$

## Exponentielle Eing√§nge 2

<!-- KJA Fig 8.2 -->

```{python}
#| echo: false
#| fig-width: 10
#| fig-height: 6

import numpy as np
import matplotlib.pyplot as plt

# Create figure with 2 rows and 3 columns
fig, axes = plt.subplots(2, 3, figsize=(10, 6))

# Define the six cases
cases = [
    # Top row
    {'s': 0 + 0j, 'title': '$s = 0$', 'row': 0, 'col': 0, 'tend': 5},
    {'s': -1 + 0j, 'title': '$s = -1$', 'row': 0, 'col': 1, 'tend': 5},
    {'s': 1 + 0j, 'title': '$s = 1$', 'row': 0, 'col': 2, 'tend': 5},
    # Bottom row
    {'s': 0 + 1j, 'title': '$s = \\pm j$', 'row': 1, 'col': 0, 'tend': 15},
    {'s': -0.2 + 1j, 'title': '$s = -0.2 \\pm j$', 'row': 1, 'col': 1, 'tend': 15},
    {'s': 0.2 + 1j, 'title': '$s = 0.2 \\pm j$', 'row': 1, 'col': 2, 'tend': 15},
]

for case in cases:
    s = case['s']
    ax = axes[case['row'], case['col']]
    tend = case['tend']
    
    # Create time vector for this specific plot
    t = np.linspace(0, tend, 500)
    
    # Calculate u(t) = e^(st)
    # For complex s, we take the real part of the sum u(t) + u*(t)
    if s.imag != 0:
        # Complex case: u(t) + u*(t) = 2*Re(e^(st)) = 2*e^(sigma*t)*cos(omega*t)
        sigma = s.real
        omega = s.imag
        u_t = 2 * np.exp(sigma * t) * np.cos(omega * t)
        
        # Plot envelope for middle and right plots in bottom row
        if case['col'] >= 1:
            envelope_pos = 2 * np.exp(sigma * t)
            envelope_neg = -2 * np.exp(sigma * t)
            ax.plot(t, envelope_pos, 'gray', linewidth=1, linestyle='--', alpha=0.6)
            ax.plot(t, envelope_neg, 'gray', linewidth=1, linestyle='--', alpha=0.6)
    else:
        # Real case
        u_t = np.exp(s.real * t)
    
    # Plot the signal
    ax.plot(t, u_t, 'b-', linewidth=1.5)
    ax.set_xlabel('Time $t$', fontsize=9)
    ax.set_ylabel('Signal $u(t)$', fontsize=9)
    ax.set_title(case['title'], fontsize=10)
    ax.grid(True, alpha=0.3)
    
    # Set reasonable y-limits for better visualization
    if case['col'] == 2 and case['row'] == 0:  # s=1 case
        ax.set_ylim([0, 150])
    elif case['col'] == 2 and case['row'] == 1:  # s=0.2+j case
        ax.set_ylim([-15, 15])

plt.tight_layout()
plt.show()
```

## Ausg√§nge f√ºr exponentielle Eing√§nge 1

 - Faltungsgleichung beschreibt Ausgang vollst√§ndig
     - $y(t) = C e^{At} x_0 + \int_0^t C e^{A(t-\tau)} B u(\tau) d\tau + D u(t)$ <!-- KJA Gl. 5.15 und Lunze Gl. 5.17-->
 - Einsetzen von $u(t) = e^{s t}$
     - $y(t) = C e^{At} x_0 + \int_0^t C e^{A(t-\tau)} B e^{s \tau} d\tau + D e^{s t} = C e^{At} x_0 + C e ^{A t} \int_0^t e^{(sI-A) \tau} B d\tau + D e^{s t}$ <!-- KJA S. 231 -->
 - Wenn $(sI-A)$ invertierbar ist ($s$ ist kein Eigenwert von $A$), dann k√∂nnen wir analytisch integrieren
     - $y(t) = C e^{At} x_0 + C e ^{A t} (sI-A)^{-1} \left[ e^{(sI-A) t} - I \right] B + D e^{s t}$

## Ausg√§nge f√ºr exponentielle Eing√§nge 2 \label{sec:herleitung2}


 - Umformen
     - $y(t) = \underbrace{C e^{At} \left[ x_0 - (sI-A)^{-1} B \right]}_{\text{transiente Antwort}} + \underbrace{\left[ C (sI-A)^{-1} B + D \right] e^{s t}}_{\text{station√§re Antwort}}$
 - Wenn das System asymptotisch stabil ist, dann wird die transiente Antwort gegen Null gehen
 - Die station√§re Antwort f√ºr Grundform $u(t) = e^{s t}$ als Eingang kann geschrieben werden
   $y_{stat}(t) = G(s) e^{s t}$
   mit einer komplexen Zahl $G(s)$
 - Die Funktion $G(s)$ nennt man die *√úbertragungsfunktion*. Sie beschreibt wie das System den Eingang in Grundform $e^{s t}$ zum Ausgang $G(s) e^{s t}$ transformiert.

## Eine T√ºr √∂ffnet sich...

::: {.columns}
::: {.column width="70%"}
 - Ansatz mit Grundformen erm√∂glicht die Faltungsgleichung zu l√∂sen.
 - Die station√§re L√∂sung $y_{stat}(t)$ wurde im Zeitbereich beschrieben.
 - Es liegt nahe, die √úbertragungsfunktion $G(s)$ weiter zu untersuchen
   - Hierzu f√ºhren wir mathematische Werkzeuge ein (Laplace-Transformation, Frequenzanalyse, komplexe Zahlen...)
   - Dieser Student liess sich davon beeindrucken
   - Konkrete Aufgaben verwenden immer reelle Zahlen (z.B. √ºber konjugierte komplexe Zahlen)
   - Lassen Sie dies nicht geschehen und glauben Sie an das Licht am Ende des Tunnels. Klassische Werkzeuge f√ºr lineare zeitinvariante Systeme sind erstaunlich m√§chtig und einfach zu benutzen!
:::
::: {.column width="30%"}
![Ein Student](Bilder/student.jpeg)
:::
:::

## ...in den Frequenzbereich

 - Betrachten wir einen sinusf√∂rmigen Eingang (zwei Grundformen, $s = \pm j \omega$)
   $$u(t) = e^{j \omega t} + e^{-j \omega t} = 2 \cos(\omega t) $$
 - Die station√§re Antwort f√ºr diese Eing√§nge und eine beliebige √úbertragungsfunktion $G(s)$ ist
   $$y_{stat}(t) = G(j \omega) e^{j \omega t} + G(-j \omega) e^{-j \omega t}$$
   $$ = M e^{\theta} e^{j \omega t} + M^* e^{-\theta^*} e^{-j \omega t} = 2 M \cos(\omega t + \theta)$$
 - Der Ausgang ist also ebenfalls ein sinusf√∂rmiges Signal der gleichen Frequenz $\omega$.
   - Die Amplitude wird durch $M = \vert G(j \omega) \vert$ verst√§rkt
   - Die Phase wird durch $\theta = \arg(G(j \omega)) = arctan(\frac{\Im(G(j \omega))}{\Re(G(j \omega))})$ verschoben <!-- KJA S. 250, Lunze Gl. 6.64 -->
   
## Lineare, zeitinvariante Systeme erlauben Superposition

 - Dank Superposition finden wir die station√§ren Ausg√§nge f√ºr komplexere Eing√§nge √ºber Zerlegung der Eing√§nge in Grundformen^[Viele periodische und nichtperiodische Signale, Sprung, Dirac-Impuls aber keine Signale, die schneller als exponentiell wachsen wie $t^t$ oder unendlich viele Diskontinuit√§ten enthalten. Formale Definition folgt sp√§ter.]
 - Wiederholung: Wenn
   - $y_1(t)$ die station√§re Antwort f√ºr Eingang $u_1(t)$ ist
   - $y_2(t)$ die station√§re Antwort f√ºr Eingang $u_2(t)$ ist
   
   Dann:
   - Ist $\alpha y_1(t) + \beta y_2(t)$ die station√§re Antwort f√ºr Eingang $\alpha u_1(t) + \beta u_2(t)$

   Allgemeiner:
   - $u(t) = \sum_{i=1}^N U_i e^{s_i t} \implies y(t) = \sum_{i=1}^N U_i G(s_i) e^{s_i t}$


## Beispiel 2 {.unnumbered}

<div style="text-align: center; padding: 50px;">
  <a href="simulation1.html" target="_blank" style="font-size: 0.8em; padding: 20px; background: #039be5; color: white; text-decoration: none; border-radius: 10px;">
    Feder-Masse-Schwinger 1 in neuem Tab √∂ffnen
  </a>
</div>

::: notes
√ñffne die Simulation in einem neuen Tab. Danach mit Alt+Tab zur√ºck zur Pr√§sentation!
 - √úbertragungsfunktion aus A, B, C, D berechnen. Aufgabe: Finde station√§re L√∂sung f√ºr u = sin( omega t). Verwende konjugiert komplexes Paar von s. Berechne u1, u2, y1, y2. Berechne y = y1+y2. Plot y_stat, y, u.
 - Ergibt immer reelle Antwort wenn paar konjugiert komplexer Argumente verwendet wird
:::


## Konvertierung Zustandsraum zu √úbertragungsfunktion

 - Wie auf Folie \label{sec:herleitung2} gezeigt
   $G(s) = C (sI-A)^{-1} B + D$  <!-- Lunze Gl. 6.75 -->
 - Wenn $A$ diagnonal mit Eigenwerten $\lambda_i$ ist (*kanonische Form*), dann erhalten wir
   $G(s) = \frac{c_1 b_1}{s-\lambda_1} + \frac{c_2 b_2}{s-\lambda_2} + \dots \frac{c_n b_n}{s-\lambda_n} + d$ <!-- Lunze Gl. 6.71 -->
 - Wenn $A$ nicht diagnonal ist, dann per Hand Faddeev-Algorithmus anwenden (Lunze Regelungstechnik 1) oder (f√ºr gro√üe Systeme) rechnergest√ºtzt Varga und Sima.

## Konvertierung √úbertragungsfunktion zu Zustandsraum 1

 - Bei vorgegebener √úbertragungsfunktion $G(s)$ gibt es keine eindeutig definierte Zustandsraumdarstellung
 - Es ist naheliegend eine Zustandsraumdarstellung mit minimaler Anzahl an Zust√§nden zu w√§hlen (*minimale Realisierung*). Solch eine Realisierung ist immer steuerbar und beobachtbar.
 - Wenn sich die √úbertragunsfunktion in Partialbr√ºchen folgender Form schreiben l√§sst 
   $G(s) = \frac{p_1}{s-\lambda_1} + \frac{p_2}{s-\lambda_2} + \dots \frac{p_n}{s-\lambda_n} + d$ 

   dann ist eine Kanonische Form

   $A = \begin{bmatrix}
   \lambda_1 &        &      \\
             & \ddots &      \\
             &        & \lambda_n  \\
   \end{bmatrix}, \quad
   B = \begin{bmatrix}
   \sqrt{p_1} \\
   \vdots \\
   \sqrt{p_n} 
   \end{bmatrix}$
   
   $C = \begin{bmatrix}
   \sqrt{p_1} & \dots & \sqrt{p_n}  \\
   \end{bmatrix}, \quad
   D = \begin{bmatrix}d\end{bmatrix}$ 

::: notes
Fragen
 - Kann jemand erkennen warum die Konvertierung von √úbertragungsfunktion zu Zustandsraum nicht eindeutig ist? u=Ax + Bu -> Die Verst√§rkung von Eing√§ngen im Vergleich zu Zust√§nden ist nicht eindeutig f√ºr station√§re Antwort. Wir w√§hlen die beiden Werte gleich als Wurzeln der Z√§hler der Partialbr√ºche (Vergleich zu der vorherigen Folie).
:::

## Konvertierung √úbertragungsfunktion zu Zustandsraum 2

 - Im Allgemeinen kann die √úbertragungsfunktion oft nicht in den einfachen Partialbr√ºchen dargestellt werden
 - Stattdessen liegt die √úbertragungsfunktion oft in der Form vor
   $G(s) = \frac{b_{n-1}s^{n-1} + \dots + b_1 s + b_0}{s^n + a_{n-1}s^{n-1} + \dots + a_1 s + a_0} + d$

 - In diesem Fall w√§hlt man i.d.R. die *Regelungsnormalform* (auch steuerbare kanonische Form, Engl. *controllable canonical form*) als minimale Realisierung
   
   $A = \begin{bmatrix}
   0 & 1 & 0 & \dots & 0 \\
   0 & 0 & 1 & \dots & 0 \\
   \vdots & \vdots & \vdots & \ddots & \vdots \\
   0 & 0 & 0 & \dots & 1 \\
   -a_0 & -a_1 & -a_2 & \dots & -a_{n-1} \\
   \end{bmatrix}, \quad
   B = \begin{bmatrix}
   0 \\
   0 \\
   \vdots \\
   0 \\
   1 \\
   \end{bmatrix}$
   
   $C = \begin{bmatrix}
   b_0 & b_1 & b_2 & \dots & b_{n-1} \\
   \end{bmatrix}, \quad
   D = \begin{bmatrix}d\end{bmatrix}$


## Der zweite Schritt in den Frequenzbereich

 - Wir haben nun die Strecke genau beschrieben (Zustandsraum, √úbertragungsfunktion).
 - Als Eing√§nge verwenden wir Summen konjugiert komplexer Argumente f√ºr Grundformen $e^{s t}$, die reelle Zahlen ergeben. 

   $u(t) = \sum_{i=1}^N U_i e^{s_i t} \implies y(t) = \sum_{i=1}^N U_i G(s_i) e^{s_i t}$

   Diese einfache, h√§ndische Handhabung der Eing√§nge ist (noch) eine erhebliche Einschr√§nkung.

 - Ziel: Anwendung der Laplace-Transformation (Vgl. Fourier-Transformation) um Eingangssignale in (die hier eingef√ºhrten) Grundformen zu zerlegen

## Laplace-Transformation 1

 - Transformiert Eingang $u(t)$ aus dem Zeitbereich in den Frequenzbereich $U(s)$ (dargestellt in Verst√§rkung und Phasenverschiebung wie bisher mit komplexen Zahlen) 
 - Diese Transformation schreiben wir als $\mathcal{L}\{u\} = U$
 - Die Transformation ist definiert durch
   $U(s) := \int_{0}^{\infty} u(t) e^{-s t} dt$ <!-- KJA eq. 8.22, Lunze Gl. 6.45 -->
 - Bedingungen: *Dirichlet-Bedingung*, $\int_{-\infty}^{\infty} \vert u(t) \vert e^{- \delta t} dt < \infty$, d.h., $u(t)$ dar nicht schneller als exponentiell wachsen (nicht $t^t$) und $u(t)$ darf nicht unendlich viele Diskontinuit√§ten enthalten.

## Laplace-Transformation 2

 - Die inverste Laplace-Transformation transformiert aus dem Frequenzbereich $U(s)$ in den Zeitbereich 
 - Diese Transformation schreiben wir als $\mathcal{L^{-1}}\{U\} = u$
 - Die inverse Transformation ist definiert durch
   $u(t) := \frac{1}{2\pi j} \lim_{\omega \to \infty} \int_{\gamma - j\omega}^{\gamma + j\omega} U(s) e^{-s t} ds$ <!-- Lunze Gl. 6.49 -->
 - Sie m√ºssen diese Laplace-Integrale nicht selber l√∂sen sondern den praktischen Umgang mit Zeit- und Frequenzbereich verstehen.

## Zwischenzusammenfassung

 - Wir finden die (station√§ren) Ausg√§nge im Zeitbereich (wenn ben√∂tigt) √ºber

   $y(t) = \frac{1}{2\pi j} \lim_{\omega \to \infty} \int_{\gamma - j\omega}^{\gamma + j\omega} G(s) U(s) e^{-s t} ds$

   Beachte, dies ist gleich

   $y(t) = \mathcal{L^{-1}}\{GU\}(t)$

 - Mit der Laplacetransformation finden bzw. definieren wir

   $\mathcal{L}\{y\}(s) = G(s)U(s)$   

   $\implies Y(s) = G(s)U(s)$   


*Vgl. Motivation: Wenn wir uns an den Frequenzbereich halten und Signale darin betrachten lernen, dann k√∂nnen viele Operationen einfacher durchgef√ºhrt werden (wie diese Multiplikation, d.h. Algebra statt Analysis)*



## Rechenregeln: Blockdiagramme


<!-- KJA fig 8.6, Lunze Beispiel 6.5.6 -->

::: {.columns}
::: {.column width="33%"}
**Reihenschaltung**

```{python}
#| echo: false
#| fig-width: 3
#| fig-height: 1.5

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
from matplotlib.patches import FancyBboxPatch, Circle, FancyArrowPatch

fig, ax = plt.subplots(figsize=(3, 1.5))
ax.set_xlim(0, 10)
ax.set_ylim(0, 3)
ax.axis('off')

# Nodes
ax.add_patch(Circle((1, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(1, 1.5, 'u', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((3, 1), 1.2, 1, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(3.6, 1.5, '$G_1$', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((5.5, 1), 1.2, 1, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(6.1, 1.5, '$G_2$', ha='center', va='center', fontsize=10)

ax.add_patch(Circle((8.5, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(8.5, 1.5, 'y', ha='center', va='center', fontsize=10)

# Arrows
ax.annotate('', xy=(2.9, 1.5), xytext=(1.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(5.4, 1.5), xytext=(4.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(8.2, 1.5), xytext=(6.8, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))

plt.tight_layout()
plt.show()
```

$$G_{yu} = G_2 \cdot G_1$$
:::

::: {.column width="33%"}
**Parallelschaltung**

```{python}
#| echo: false
#| fig-width: 3
#| fig-height: 1.5

import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Circle

fig, ax = plt.subplots(figsize=(3, 1.5))
ax.set_xlim(0, 10)
ax.set_ylim(0, 3)
ax.axis('off')

# Nodes
ax.add_patch(Circle((1, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(1, 1.5, 'u', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((3, 1.8), 1.2, 0.8, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(3.6, 2.2, '$G_1$', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((3, 0.4), 1.2, 0.8, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(3.6, 0.8, '$G_2$', ha='center', va='center', fontsize=10)

ax.add_patch(Circle((6, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(6, 1.5, '+', ha='center', va='center', fontsize=10)

ax.add_patch(Circle((8.5, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(8.5, 1.5, 'y', ha='center', va='center', fontsize=10)

# Arrows
ax.annotate('', xy=(2.9, 2.2), xytext=(1.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(2.9, 0.8), xytext=(1.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(5.7, 1.7), xytext=(4.3, 2.2),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(5.7, 1.3), xytext=(4.3, 0.8),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(8.2, 1.5), xytext=(6.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))

plt.tight_layout()
plt.show()
```

$$G_{yu} = G_1 + G_2$$
:::

::: {.column width="33%"}
**R√ºckkopplung (Feedback)**

```{python}
#| echo: false
#| fig-width: 3
#| fig-height: 1.5

import matplotlib.pyplot as plt
from matplotlib.patches import FancyBboxPatch, Circle

fig, ax = plt.subplots(figsize=(3, 1.5))
ax.set_xlim(0, 10)
ax.set_ylim(0, 3)
ax.axis('off')

# Nodes
ax.add_patch(Circle((1, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(1, 1.5, 'u', ha='center', va='center', fontsize=10)

ax.add_patch(Circle((2.5, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(2.5, 1.5, '+', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((4, 1), 1.2, 1, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(4.6, 1.5, '$G_1$', ha='center', va='center', fontsize=10)

ax.add_patch(Circle((7, 1.5), 0.3, fill=False, edgecolor='black'))
ax.text(7, 1.5, 'y', ha='center', va='center', fontsize=10)

ax.add_patch(FancyBboxPatch((4, 0.1), 1.2, 0.6, boxstyle="round,pad=0.05", 
                             fill=False, edgecolor='black'))
ax.text(4.6, 0.4, '$G_2$', ha='center', va='center', fontsize=10)

# Arrows
ax.annotate('', xy=(2.2, 1.5), xytext=(1.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.annotate('', xy=(3.9, 1.5), xytext=(2.8, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.text(3.4, 1.7, 'e', ha='center', va='bottom', fontsize=9)
ax.annotate('', xy=(6.7, 1.5), xytext=(5.3, 1.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
# Feedback path
# From bottom of y to right side of G2
ax.plot([7, 7, 5.3, 5.3], [1.2, 0.4, 0.4, 0.4], 'k-', lw=1.5)
ax.annotate('', xy=(5.2, 0.4), xytext=(5.3, 0.4),
            arrowprops=dict(arrowstyle='->', lw=1.5))
# From left side of G2 to summation
ax.plot([4, 2.5, 2.5], [0.4, 0.4, 1.2], 'k-', lw=1.5)
ax.annotate('', xy=(2.5, 1.2), xytext=(2.5, 0.5),
            arrowprops=dict(arrowstyle='->', lw=1.5))
ax.text(2.8, 0.8, '‚àí', ha='left', va='center', fontsize=10)

plt.tight_layout()
plt.show()
```

$$G_{yu} = \frac{G_1}{1 + G_1 G_2}$$
:::
:::





## Eigenschaften der √úbertragungsfunktion

<!-- Lunze 6.3.3 -->
 - F√ºr technisch interessante Systeme $G(s) = \frac{b_{n-1}s^{n-1} + \dots + b_1 s + b_0}{s^n + a_{n-1}s^{n-1} + \dots + a_1 s + a_0} + d$: Z√§hlergrad $q$ √ºbersteigt Nennergrad $n$ nicht, d.h. $q \leq n$
 - Statische Verst√§rkung: $G(0) = \frac{b_0}{a_0}$
 - Signale sehr hoher Frequenz werden nicht (wenn Durchgriff $d=0$) oder mit Verst√§rkung √ºbertragen
    - $\lim_{\omega \to \infty} G(j\omega) = \begin{cases}\frac{b_n}{a_n} + d \quad \text{f√ºr } q=n\\d \quad \text{f√ºr } q<n\end{cases}$
 - √úbertragungsfunktionen sind symmetrisch
    - $\vert G(j\omega) \vert = \vert G(-j\omega) \vert$
    - $\angle G(-j\omega) = -\angle G(j\omega)$
 - Weitere √úberlegungen
    - Uns interessiert der Frequenzgang $G(j\omega)$: Verst√§rkung und Phasenverschiebung
    - Der Einfluss der D√§mpfung $\sigma$ in $G(\sigma \pm j\omega)$ braucht nicht detailliert analysiert werden, da dieser wegen Linearit√§t unabh√§ngig aufgeschlagen werden kann 


## Darstellungen der √úbertragunsfunktion 1

::: {.columns}
::: {.column width="60%"}
 - *Bode-Diagramm* (auch *Frequenzkennliniendiagramm*) <!-- Lunze 6.3.3 -->
    - Oben: $\vert G(j\omega) \vert_{dB}$ als Funktion von $\log_{10} \omega$
    - Unten: $\angle G(j\omega)_{deg}$ als Funktion von $\log_{10} \omega$

```{python}
#| echo: false
#| fig-width: 8
#| fig-height: 5

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Transfer function: G(s) = (s+2)/(8s^2 + 3s + 4)
num = [1, 2]
den = [8, 3, 4]
sys = signal.TransferFunction(num, den)

# Frequency range (log scale)
w = np.logspace(-1, 1, 100)

# Compute frequency response
w, H = signal.freqs(num, den, w)

# Convert to magnitude (dB) and phase (degrees)
mag_db = 20 * np.log10(np.abs(H))
phase_deg = np.angle(H) * 180 / np.pi

# Create figure with two subplots
fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(8, 5))

# Magnitude plot
ax1.semilogx(w, mag_db, 'b-', linewidth=2)
ax1.grid(True, which='both', alpha=0.3)
ax1.set_ylabel('|G| [dB]', fontsize=12)
ax1.set_ylim([-40, 5])
ax1.axhline(0, color='k', linewidth=0.5)

# Phase plot
ax2.semilogx(w, phase_deg, 'b-', linewidth=2)
ax2.grid(True, which='both', alpha=0.3)
ax2.set_xlabel('œâ [rad/s]', fontsize=12)
ax2.set_ylabel('‚à†G [¬∞]', fontsize=12)
ax2.set_ylim([-130, 5])
ax2.axhline(0, color='k', linewidth=0.5)

plt.tight_layout()
plt.show()
```

:::
::: {.column width="40%"}
| $\vert G(j\omega) \vert$ | $\vert G(j\omega) \vert_{dB} = 20 \log_{10} \vert G \vert$ |
|:------------------------:|:-----------------------------:|
|  100                     |      40                       |
|  10                      |      20                       |
|  1                       |      0                        |
|  0.1                     |      -20                      |
|  0.01                    |      -40                      |
:::
:::


## Darstellungen der √úbertragunsfunktion 2

 - *Nyquist-Diagramm* (auch *Ortskurve*)
    - Von einem Zeiger mit L√§nge $\vert G(j\omega) \vert$ und Winkel $\angle G(j\omega)$ gezeichnete Ortskurve

```{python}
#| echo: false
#| fig-width: 6
#| fig-height: 6

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Transfer function
num = [1, 2]
den = [8, 3, 4]
sys = signal.TransferFunction(num, den)

# Frequency range
w = np.logspace(-2, 2, 500)

# Compute frequency response
w, H = signal.freqs(num, den, w)

# Nyquist plot
plt.figure(figsize=(6, 6))
plt.plot(H.real, H.imag, 'b', linewidth=2)
plt.plot(H.real, -H.imag, 'b--', linewidth=1, alpha=0.5)

# Add arrow and labels for specific frequency
omega_example = 0.6
# Find the point on the curve closest to given omega 
idx = np.argmin(np.abs(w - omega_example))
H_point = H[idx]

# Draw arrow from origin to the point
plt.annotate('', xy=(H_point.real, H_point.imag), xytext=(0, 0),
            arrowprops=dict(arrowstyle='->', color='red', lw=2))

# Add magnitude label along the arrow
mid_real = H_point.real / 1.5
mid_imag = H_point.imag / 1.5
plt.text(mid_real, mid_imag + 0.15, r'$|G(j\omega)|$', 
         fontsize=12, color='red', ha='center')

# Draw angle arc
angle = np.angle(H_point)
arc_radius = 0.4
arc_angles = np.linspace(0, angle, 30)
arc_x = arc_radius * np.cos(arc_angles)
arc_y = arc_radius * np.sin(arc_angles)
plt.plot(arc_x, arc_y, 'g-', linewidth=1.5)

# Add angle label
label_angle = angle / 2
label_radius = arc_radius + 0.08
plt.text(label_radius * np.cos(label_angle), 
         label_radius * np.sin(label_angle), 
         r'$\phi(\omega)$', fontsize=12, color='green', ha='left')

# Mark the point
plt.plot(H_point.real, H_point.imag, 'ro', markersize=8)

# Formatting
plt.axhline(0, color='k', linewidth=0.5)
plt.axvline(0, color='k', linewidth=0.5)
plt.grid(True, alpha=0.3)
plt.xlabel('Real')
plt.ylabel('Imagin√§r')
plt.axis('equal')
plt.show()
```


## Beispiele von √úbertragungsfunktionen

<!-- Lunze Abb. 6.54 -->

```{python}
#| echo: false
#| fig-width: 12
#| fig-height: 8

import numpy as np
import matplotlib.pyplot as plt
from scipy import signal

# Define transfer functions
systems = {
    'Proportional': {'num': [1], 'den': [1], 'formula': r'$G(s) = K$'},
    'Integral': {'num': [0.5], 'den': [1, 0], 'formula': r'$G(s) = \frac{K}{s}$'},
    'Differenzial': {'num': [1, 0], 'den': [0.1, 1], 'formula': r'$G(s) = Ks$'},
    'PT1-Glied': {'num': [1], 'den': [1, 1], 'formula': r'$G(s) = \frac{K}{Ts+1}$'},
    'PT2-Glied': {'num': [1], 'den': [1, 1, 1], 'formula': r'$G(s) = \frac{K}{Ts^2+Ts+1}$'},
#    'Totzeit': {'num': [1], 'den': [1], 'delay': 0.5, 'formula': r'$G(s) = e^{-Ts}$'}
}

# Time and frequency arrays
t = np.linspace(0, 5, 500)
w = np.logspace(-2, 2, 200)

# Create figure with subplots - 6 columns (1 for labels + 5 for systems), 3 rows with height ratios
fig = plt.figure(figsize=(17, 7))
gs = fig.add_gridspec(4, 6, hspace=0.4, wspace=0.3, 
                      height_ratios=[0.3, 1.6, 1, 1], width_ratios=[0.2, 1, 1, 1, 1, 1])

# Add row labels on the left
row_labels = ['Ausdruck', 'Sprungantwort', 'Bode-Diagramm', '']
for row_idx, label in enumerate(row_labels):
    ax_label = fig.add_subplot(gs[row_idx, 0])
    ax_label.text(0.5, 0.5, label, ha='center', va='center', 
                  fontsize=11, fontweight='bold', rotation=90, transform=ax_label.transAxes)
    ax_label.axis('off')

for idx, (name, params) in enumerate(systems.items()):
    # Offset column index by 1 to account for label column
    col_idx = idx + 1
    # Create transfer function
    sys = signal.TransferFunction(params['num'], params['den'])
    
    # Handle time delay for dead time
    if 'delay' in params:
        t_response, y_response = signal.step(sys, T=t)
        # Apply delay
        delay_samples = int(params['delay'] / (t[1] - t[0]))
        y_delayed = np.zeros_like(y_response)
        if delay_samples < len(y_response):
            y_delayed[delay_samples:] = y_response[:-delay_samples]
        y_response = y_delayed
        t_response = t
    else:
        t_response, y_response = signal.step(sys, T=t)
    
    # Compute frequency response
    w_sys, H = signal.freqs(params['num'], params['den'], w)
    
    # Apply delay in frequency domain for dead time
    if 'delay' in params:
        H = H * np.exp(-1j * w_sys * params['delay'])
    
    mag_db = 20 * np.log10(np.abs(H) + 1e-10)
    phase_deg = np.angle(H) * 180 / np.pi
    
    # Row 1: Transfer function formula
    ax1 = fig.add_subplot(gs[0, col_idx])
    ax1.text(0.5, 0.5, params['formula'], ha='center', va='center', 
             fontsize=12, transform=ax1.transAxes)
    ax1.set_title(name, fontsize=10, fontweight='bold')
    ax1.axis('off')

    # Row 2: Time response
    ax2 = fig.add_subplot(gs[1, col_idx])
    ax2.plot(t_response, y_response, 'b-', linewidth=1.5)
    ax2.grid(True, alpha=0.3)
    ax2.set_ylim([-0.2, 2.5])
    ax2.set_xlabel('t [s]', fontsize=8)
    ax2.set_ylabel('y(t)', fontsize=8)
    ax2.tick_params(labelsize=7)
        
    # Row 3: Bode magnitude
    ax3 = fig.add_subplot(gs[2, col_idx])
    ax3.semilogx(w_sys, mag_db, 'b-', linewidth=1.5)
    ax3.grid(True, which='both', alpha=0.3)
    ax3.set_ylim([-60, 20])
    ax3.set_xlabel('œâ [rad/s]', fontsize=8)
    ax3.set_ylabel('|G| [dB]', fontsize=8)
    ax3.tick_params(labelsize=7)
    ax3.axhline(0, color='k', linewidth=0.5)

    # Row 4: Bode phase
    ax4 = fig.add_subplot(gs[3, col_idx])
    ax4.semilogx(w_sys, phase_deg, 'b-', linewidth=1.5)
    ax4.grid(True, which='both', alpha=0.3)
    ax4.set_ylim([-180, 100])
    ax4.set_xlabel('œâ [rad/s]', fontsize=8)
    ax4.set_ylabel('‚à†G [¬∞]', fontsize=8)
    ax4.tick_params(labelsize=7)
    ax4.axhline(0, color='k', linewidth=0.5)

plt.tight_layout()
plt.show()
```


## Nullstellen und Pole

 - Pole
    - Definieren die Eigenbewegungen (auch Modi) des Systems
    - Stabile systeme haben Pole mit negativen Realteilen (Eigenbewegungen klingen ab)
    - Verst√§rkung von Eing√§ngen, die Eigenbewegungen sind, wird unendlich
 - Nullstellen 
    - Bestimmen Eing√§nge, die vom System nicht √ºbertragen werden (Verst√§rkung verschwindet in station√§rer L√∂sung)
    - Erzwungene Bewegung (im Gegensatz zu station√§rer L√∂sung) sowie andere Grundeing√§nge f√ºhren in der Regel zu einer √Ñnderung des Ausgangs

*Vgl. Motivation: Insbesondere Pole (d.h. Stabilit√§t) aber auch Nullstellen werden in Regelungstechnik f√ºr Strecke und geregelte Strecke entscheidend. Es ist n√ºtzlich diese vorhersagen und algebraisch berechnen zu k√∂nnen.*

::: notes
Bez√ºglich Regelung k√∂nnen wir noch keine Aussage zur G√ºte der Regelung treffen. Aber ob ein geregelte System stabil ist, ist ein wichtiges Ergebnis. Wir k√∂nnen dies auch konstruktiv nutzen und ableiten, wie wir ein System stabil machen k√∂nnen.
:::

<!-- KJA p 239, lunze S. 241/242 -->


## Beispiel 3 {.unnumbered}

<div style="text-align: center; padding: 50px;">
  <a href="simulation2.html" target="_blank" style="font-size: 0.8em; padding: 20px; background: #039be5; color: white; text-decoration: none; border-radius: 10px;">
    Feder-Masse-Schwinger 2 in neuem Tab √∂ffnen
  </a>
</div>

::: notes
√ñffne die Simulation in einem neuen Tab. Danach mit Alt+Tab zur√ºck zur Pr√§sentation!
 - Erkennen von Nullstellen und Polen in Systemen aus Bodediagramm. Darstellung von entsprechenden Ergebnissen im Zeitbereich.
 - Pol-Nullstellendiagramm???
:::

<!-- Lunze Beispiel 6.4 -->

## R√ºckblick Lernziele

 - Vorteile der Betrachtung im Frequenzbereich: Einfache (algebraische) Berechnung!
 - Ausgang f√ºr exponentielle Eing√§nge
 - √úbertragungsfunktion
 - Umrechnung von Zustandsraum zu √úbertragungsfunktion und umgekehrt
 - Laplace-Transformation und umgekehrte Laplace-Transformation
 - *Nullstellen und Pole*
 - *Bode-Diagramme*

<!-- Fehlt/bleibt weg wegen Zeit: Reglerentwurf prinzipiell? Optimierungs- und simulationsbasiert einerseits (ohne √úbertragungsfunktion), andererseits Synthese mit √úbertragungsfunktion. -->


## Referenzen

::: {.columns}
::: {.column width="70%"}
<!-- In Kommentaren genannt KJA -->
Astr√∂m, K.J., Murray, R.M. (2008). Feedback Systems: An Introduction for Scientists and Engineers. Princeton University Press.

<!-- In Kommentaren genannt Lunze -->
Lunze, D. (2022). Regelungstechnik 1: Grundlagen und Praktikum. Springer Spektrum.

Varga, A, Sima, V.: "Numerically stable algorithm for transfer function matrix evaluation" Int. J. 
Control, vol. 33, No. 6, pp. 1123-1133, 1981 

Tani, J. (2017). Control Systems I. Lecture Notes. ETH Zurich.
:::

::: {.column width="30%"}
Unterlagen auf GitHub:
![](Bilder/github_qr.png)
:::
:::


